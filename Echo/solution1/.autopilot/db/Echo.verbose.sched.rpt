

================================================================
== Vivado HLS Report for 'Echo'
================================================================
* Date:           Thu Apr 25 12:29:42 2019

* Version:        2017.2 (Build 1909853 on Thu Jun 15 18:55:24 MDT 2017)
* Project:        Echo
* Solution:       solution1
* Product family: zynq
* Target device:  xc7z100ffg900-1


================================================================
== Performance Estimates
================================================================
+ Timing (ns): 
    * Summary: 
    +--------+-------+----------+------------+
    |  Clock | Target| Estimated| Uncertainty|
    +--------+-------+----------+------------+
    |ap_clk  |  10.00|      7.26|        1.25|
    +--------+-------+----------+------------+

+ Latency (clock cycles): 
    * Summary: 
    +-----+-----+-----+-----+---------+
    |  Latency  |  Interval | Pipeline|
    | min | max | min | max |   Type  |
    +-----+-----+-----+-----+---------+
    |   12|   12|   13|   13|   none  |
    +-----+-----+-----+-----+---------+

    + Detail: 
        * Instance: 
        N/A

        * Loop: 
        N/A

============================================================
+ Verbose Summary: Synthesis Manager
============================================================
InlineROM: 1
ExposeGlobal: 0
============================================================
+ Verbose Summary: CDFG Model
============================================================
IsTopModel: 1
ResetActiveHigh: 1
IsCombinational: 0
IsDatapathOnly: 0
HasWiredReturn: 1
HasMFsm: 0
HasVarLatency: 1
IsPipeline: 0
IsRtlPipelined: 0
IsInstanceOverlapped: 0
IsDontTouch: 0
HasImplIP: 0
IsGatedGlobalClock: 0


============================================================
+ Verbose Summary: Schedule
============================================================
* Number of FSM states: 13
* Pipeline: 0
* Dataflow Pipeline: 0

* FSM state transitions: 
1 --> 
	2  / true
2 --> 
	3  / true
3 --> 
	4  / true
4 --> 
	5  / true
5 --> 
	6  / true
6 --> 
	7  / true
7 --> 
	8  / true
8 --> 
	9  / true
9 --> 
	10  / true
10 --> 
	11  / true
11 --> 
	12  / true
12 --> 
	13  / true
13 --> 
* FSM state operations: 

 <State 1>: 5.49ns
ST_1: StgValue_14 (9)  [1/1] 0.00ns
:0  call void (...)* @_ssdm_op_SpecBitsMap(float* %value_in_V), !map !20

ST_1: StgValue_15 (10)  [1/1] 0.00ns
:1  call void (...)* @_ssdm_op_SpecBitsMap(float* %value_out_V), !map !26

ST_1: StgValue_16 (11)  [1/1] 0.00ns
:2  call void (...)* @_ssdm_op_SpecBitsMap(i32 %delay), !map !30

ST_1: StgValue_17 (12)  [1/1] 0.00ns
:3  call void (...)* @_ssdm_op_SpecBitsMap(float %scale), !map !36

ST_1: StgValue_18 (13)  [1/1] 0.00ns
:4  call void (...)* @_ssdm_op_SpecTopModule([5 x i8]* @Echo_str) nounwind

ST_1: scale_read (14)  [1/1] 1.00ns
:5  %scale_read = call float @_ssdm_op_Read.s_axilite.float(float %scale)

ST_1: delay_read (15)  [1/1] 1.00ns
:6  %delay_read = call i32 @_ssdm_op_Read.s_axilite.i32(i32 %delay)

ST_1: StgValue_21 (16)  [1/1] 0.00ns  loc: src/Echo.cpp:23
:7  call void (...)* @_ssdm_op_SpecLatency(i32 12, i32 65535, [1 x i8]* @p_str) nounwind

ST_1: StgValue_22 (17)  [1/1] 0.00ns  loc: src/Echo.cpp:25
:8  call void (...)* @_ssdm_op_SpecInterface(i32 0, [13 x i8]* @p_str1, i32 0, i32 0, [1 x i8]* @p_str, i32 0, i32 0, [1 x i8]* @p_str, [1 x i8]* @p_str, [1 x i8]* @p_str, i32 0, i32 0, i32 0, i32 0, [1 x i8]* @p_str, [1 x i8]* @p_str) nounwind

ST_1: StgValue_23 (18)  [1/1] 0.00ns  loc: src/Echo.cpp:26
:9  call void (...)* @_ssdm_op_SpecInterface(i32 %delay, [10 x i8]* @p_str2, i32 0, i32 0, [1 x i8]* @p_str, i32 0, i32 0, [9 x i8]* @p_str3, [1 x i8]* @p_str, [1 x i8]* @p_str, i32 0, i32 0, i32 0, i32 0, [1 x i8]* @p_str, [1 x i8]* @p_str) nounwind

ST_1: StgValue_24 (19)  [1/1] 0.00ns  loc: src/Echo.cpp:27
:10  call void (...)* @_ssdm_op_SpecInterface(float %scale, [10 x i8]* @p_str2, i32 0, i32 0, [1 x i8]* @p_str, i32 0, i32 0, [9 x i8]* @p_str3, [1 x i8]* @p_str, [1 x i8]* @p_str, i32 0, i32 0, i32 0, i32 0, [1 x i8]* @p_str, [1 x i8]* @p_str) nounwind

ST_1: StgValue_25 (20)  [1/1] 0.00ns  loc: src/Echo.cpp:29
:11  call void (...)* @_ssdm_op_SpecInterface(float* %value_in_V, [5 x i8]* @p_str4, i32 1, i32 1, [5 x i8]* @p_str5, i32 0, i32 0, [1 x i8]* @p_str, [1 x i8]* @p_str, [1 x i8]* @p_str, i32 0, i32 0, i32 0, i32 0, [1 x i8]* @p_str, [1 x i8]* @p_str) nounwind

ST_1: StgValue_26 (21)  [1/1] 0.00ns  loc: src/Echo.cpp:30
:12  call void (...)* @_ssdm_op_SpecInterface(float* %value_out_V, [5 x i8]* @p_str4, i32 1, i32 1, [5 x i8]* @p_str5, i32 0, i32 0, [1 x i8]* @p_str, [1 x i8]* @p_str, [1 x i8]* @p_str, i32 0, i32 0, i32 0, i32 0, [1 x i8]* @p_str, [1 x i8]* @p_str) nounwind

ST_1: guard_variable_for_E (22)  [1/1] 0.00ns
:13  %guard_variable_for_E = load i1* @guard_variable_for_E, align 1

ST_1: readBuffer_load (23)  [1/1] 0.00ns  loc: src/Echo.cpp:41
:14  %readBuffer_load = load i32* @readBuffer, align 4

ST_1: StgValue_29 (24)  [1/1] 1.59ns  loc: src/Echo.cpp:32
:15  br i1 %guard_variable_for_E, label %._crit_edge, label %codeRepl1

ST_1: tmp_2_i (26)  [1/1] 2.90ns  loc: src/Echo.cpp:32
codeRepl1:0  %tmp_2_i = sub nsw i32 4800, %delay_read

ST_1: StgValue_31 (27)  [1/1] 0.00ns  loc: src/Echo.cpp:32
codeRepl1:1  store i1 true, i1* @guard_variable_for_E, align 1

ST_1: StgValue_32 (28)  [1/1] 1.59ns
codeRepl1:2  br label %._crit_edge


 <State 2>: 5.33ns
ST_2: readBuffer_loc (30)  [1/1] 0.00ns  loc: src/Echo.cpp:32
._crit_edge:0  %readBuffer_loc = phi i32 [ %tmp_2_i, %codeRepl1 ], [ %readBuffer_load, %0 ]

ST_2: tmp_4 (32)  [1/1] 0.00ns  loc: src/Echo.cpp:41
._crit_edge:2  %tmp_4 = sext i32 %readBuffer_loc to i64

ST_2: buffer_addr (33)  [1/1] 0.00ns  loc: src/Echo.cpp:41
._crit_edge:3  %buffer_addr = getelementptr inbounds [4800 x float]* @buffer_r, i64 0, i64 %tmp_4

ST_2: buffer_load (34)  [2/2] 3.25ns  loc: src/Echo.cpp:41
._crit_edge:4  %buffer_load = load float* %buffer_addr, align 4

ST_2: tmp_9 (42)  [1/1] 3.26ns  loc: src/Echo.cpp:47
._crit_edge:12  %tmp_9 = icmp slt i32 %readBuffer_loc, 4800

ST_2: tmp_s (43)  [1/1] 2.90ns  loc: src/Echo.cpp:48
._crit_edge:13  %tmp_s = add nsw i32 %readBuffer_loc, 1

ST_2: storemerge (44)  [1/1] 2.07ns  loc: src/Echo.cpp:47
._crit_edge:14  %storemerge = select i1 %tmp_9, i32 %tmp_s, i32 0

ST_2: StgValue_40 (49)  [1/1] 0.00ns  loc: src/Echo.cpp:32
._crit_edge:19  store i32 %storemerge, i32* @readBuffer, align 4


 <State 3>: 3.25ns
ST_3: buffer_load (34)  [1/2] 3.25ns  loc: src/Echo.cpp:41
._crit_edge:4  %buffer_load = load float* %buffer_addr, align 4


 <State 4>: 5.70ns
ST_4: tmp_5 (35)  [4/4] 5.70ns  loc: src/Echo.cpp:41
._crit_edge:5  %tmp_5 = fmul float %buffer_load, %scale_read


 <State 5>: 5.70ns
ST_5: tmp_5 (35)  [3/4] 5.70ns  loc: src/Echo.cpp:41
._crit_edge:5  %tmp_5 = fmul float %buffer_load, %scale_read


 <State 6>: 5.70ns
ST_6: tmp_5 (35)  [2/4] 5.70ns  loc: src/Echo.cpp:41
._crit_edge:5  %tmp_5 = fmul float %buffer_load, %scale_read


 <State 7>: 5.70ns
ST_7: tmp_1 (31)  [2/2] 0.00ns  loc: src/Echo.cpp:39
._crit_edge:1  %tmp_1 = call float @_ssdm_op_Read.axis.volatile.floatP(float* %value_in_V)

ST_7: tmp_5 (35)  [1/4] 5.70ns  loc: src/Echo.cpp:41
._crit_edge:5  %tmp_5 = fmul float %buffer_load, %scale_read


 <State 8>: 7.26ns
ST_8: tmp_1 (31)  [1/2] 0.00ns  loc: src/Echo.cpp:39
._crit_edge:1  %tmp_1 = call float @_ssdm_op_Read.axis.volatile.floatP(float* %value_in_V)

ST_8: current_value (36)  [5/5] 7.26ns  loc: src/Echo.cpp:41
._crit_edge:6  %current_value = fadd float %tmp_1, %tmp_5


 <State 9>: 7.26ns
ST_9: current_value (36)  [4/5] 7.26ns  loc: src/Echo.cpp:41
._crit_edge:6  %current_value = fadd float %tmp_1, %tmp_5


 <State 10>: 7.26ns
ST_10: current_value (36)  [3/5] 7.26ns  loc: src/Echo.cpp:41
._crit_edge:6  %current_value = fadd float %tmp_1, %tmp_5


 <State 11>: 7.26ns
ST_11: current_value (36)  [2/5] 7.26ns  loc: src/Echo.cpp:41
._crit_edge:6  %current_value = fadd float %tmp_1, %tmp_5


 <State 12>: 7.26ns
ST_12: current_value (36)  [1/5] 7.26ns  loc: src/Echo.cpp:41
._crit_edge:6  %current_value = fadd float %tmp_1, %tmp_5

ST_12: StgValue_53 (41)  [2/2] 0.00ns  loc: src/Echo.cpp:45
._crit_edge:11  call void @_ssdm_op_Write.axis.volatile.floatP(float* %value_out_V, float %current_value)


 <State 13>: 5.33ns
ST_13: writeBuffer_load (37)  [1/1] 0.00ns  loc: src/Echo.cpp:43
._crit_edge:7  %writeBuffer_load = load i32* @writeBuffer, align 4

ST_13: tmp_6 (38)  [1/1] 0.00ns  loc: src/Echo.cpp:43
._crit_edge:8  %tmp_6 = sext i32 %writeBuffer_load to i64

ST_13: buffer_addr_1 (39)  [1/1] 0.00ns  loc: src/Echo.cpp:43
._crit_edge:9  %buffer_addr_1 = getelementptr inbounds [4800 x float]* @buffer_r, i64 0, i64 %tmp_6

ST_13: StgValue_57 (40)  [1/1] 3.25ns  loc: src/Echo.cpp:43
._crit_edge:10  store float %current_value, float* %buffer_addr_1, align 4

ST_13: StgValue_58 (41)  [1/2] 0.00ns  loc: src/Echo.cpp:45
._crit_edge:11  call void @_ssdm_op_Write.axis.volatile.floatP(float* %value_out_V, float %current_value)

ST_13: tmp_8 (45)  [1/1] 3.26ns  loc: src/Echo.cpp:52
._crit_edge:15  %tmp_8 = icmp slt i32 %writeBuffer_load, 4800

ST_13: tmp_7 (46)  [1/1] 2.90ns  loc: src/Echo.cpp:53
._crit_edge:16  %tmp_7 = add nsw i32 %writeBuffer_load, 1

ST_13: storemerge5 (47)  [1/1] 2.07ns  loc: src/Echo.cpp:52
._crit_edge:17  %storemerge5 = select i1 %tmp_8, i32 %tmp_7, i32 0

ST_13: StgValue_62 (48)  [1/1] 0.00ns  loc: src/Echo.cpp:53
._crit_edge:18  store i32 %storemerge5, i32* @writeBuffer, align 4

ST_13: StgValue_63 (50)  [1/1] 0.00ns  loc: src/Echo.cpp:60
._crit_edge:20  ret void



============================================================
+ Verbose Summary: Timing violations
============================================================
Target clock period: 10ns, clock uncertainty: 1.25ns.

 <State 1>: 5.49ns
The critical path consists of the following:
	s_axi read on port 'delay' [15]  (1 ns)
	'sub' operation ('tmp_2_i', src/Echo.cpp:32) [26]  (2.9 ns)
	multiplexor before 'phi' operation ('readBuffer_loc', src/Echo.cpp:32) with incoming values : ('readBuffer_load', src/Echo.cpp:41) ('tmp_2_i', src/Echo.cpp:32) [30]  (1.59 ns)

 <State 2>: 5.33ns
The critical path consists of the following:
	'phi' operation ('readBuffer_loc', src/Echo.cpp:32) with incoming values : ('readBuffer_load', src/Echo.cpp:41) ('tmp_2_i', src/Echo.cpp:32) [30]  (0 ns)
	'icmp' operation ('tmp_9', src/Echo.cpp:47) [42]  (3.26 ns)
	'select' operation ('storemerge', src/Echo.cpp:47) [44]  (2.07 ns)

 <State 3>: 3.25ns
The critical path consists of the following:
	'load' operation ('buffer_load', src/Echo.cpp:41) on array 'buffer_r' [34]  (3.25 ns)

 <State 4>: 5.7ns
The critical path consists of the following:
	'fmul' operation ('tmp_5', src/Echo.cpp:41) [35]  (5.7 ns)

 <State 5>: 5.7ns
The critical path consists of the following:
	'fmul' operation ('tmp_5', src/Echo.cpp:41) [35]  (5.7 ns)

 <State 6>: 5.7ns
The critical path consists of the following:
	'fmul' operation ('tmp_5', src/Echo.cpp:41) [35]  (5.7 ns)

 <State 7>: 5.7ns
The critical path consists of the following:
	'fmul' operation ('tmp_5', src/Echo.cpp:41) [35]  (5.7 ns)

 <State 8>: 7.26ns
The critical path consists of the following:
	axis read on port 'value_in_V' (src/Echo.cpp:39) [31]  (0 ns)
	'fadd' operation ('current_value', src/Echo.cpp:41) [36]  (7.26 ns)

 <State 9>: 7.26ns
The critical path consists of the following:
	'fadd' operation ('current_value', src/Echo.cpp:41) [36]  (7.26 ns)

 <State 10>: 7.26ns
The critical path consists of the following:
	'fadd' operation ('current_value', src/Echo.cpp:41) [36]  (7.26 ns)

 <State 11>: 7.26ns
The critical path consists of the following:
	'fadd' operation ('current_value', src/Echo.cpp:41) [36]  (7.26 ns)

 <State 12>: 7.26ns
The critical path consists of the following:
	'fadd' operation ('current_value', src/Echo.cpp:41) [36]  (7.26 ns)

 <State 13>: 5.33ns
The critical path consists of the following:
	'load' operation ('writeBuffer_load', src/Echo.cpp:43) on static variable 'writeBuffer' [37]  (0 ns)
	'icmp' operation ('tmp_8', src/Echo.cpp:52) [45]  (3.26 ns)
	'select' operation ('storemerge5', src/Echo.cpp:52) [47]  (2.07 ns)


============================================================
+ Verbose Summary: Binding
============================================================
N/A
* FSMD analyzer results:
  - Output states:
 - Input state : 
  - Chain level:
	State 1
	State 2
	State 3
	State 4
	State 5
	State 6
	State 7
	State 8
	State 9
	State 10
	State 11
	State 12
	State 13


============================================================
+ Verbose Summary: Datapath Resource usage 
============================================================
N/A
